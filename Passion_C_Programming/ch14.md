Chapter 14 : Function & Pointer
-------------------------------

---

### 함수의 인자로 배열 전달<br>

```C

void SimpleFunc(int * param){ //매개변수를 int param[]으로 대체 가능
                              // -> 매개변수에서만 이렇게 변경이 가능한 것이다.
  ...
}

int main(void){
  int arr[3] = {1,2,3};
  SimpleFunc(arr);
}
```

-	함수 호출 시 전달되는 인자의 값은 매개변수에 복사가 된다.<br><br>
-	매개변수에 배열을 통째로 넘겨주는 방법은 존재하지 않는다. 하지만 함수 내에서 배열에 접근할 수 있도록 배열의 주소값은 전달하는 것은 가능하다.<br><br>
-	main에서 arr이 int형이기 때문에 SimpleFunc 매개변수로 int형 포인터를 지정한다.<br><br>
-	함수 내에서는 인자로 전달된 배열의 길이를 계산할 수 없다. -> 자바와 다른 점<br><br>
-	배열의 주소값을 인자로 전달받는 매개변수는 포인터 변수이기 때문에 `sizeof`연산을 할 경우 배열의 크기가 아닌 포인터 변수의 크기가 반환된다. 그래서 배열의 크기나 길이정보를 함께 인자로 전달해야 한다.<br><br>

### Call-by-value vs. Call-by-reference<br>

-	Call-by-value: 함수를 호출할 때 단순히 값을 전달하는 형태.<br><br>
-	Call-by-reference: 함수를 호출할 때 메모리의 접근에 사용되는 주소값을 전달하는 형태.<br><br>
-	`scanf` 함수를 호출할 때 `&`을 붙이는 이유가 입력받은 값을 num에 채운다고 할 때 num의 주소값을 알아야하기 때문이다.<br><br>
-	메모리 주소 값을 알아야 대상 변수에 접근하여 값을 채워 넣을 수 있기 때문이다.<br><br>
-	문자열은 그 자체로 배열의 주소값을 나타내기 때문에 `&` 연산자를 붙이지 않는 것이다.<br><br>

### 포인터 const 선언<br>

```C
int main(void){
  int num = 20;
  const int * ptr = &num;
  *ptr = 30; //컴파일 에러
  num = 40; //컴파일 성공

  int num2 = 15;
  int * const ptr2 = &num;
  ptr2 = &num2; //컴파일 에러
  *ptr2 = 40; //컴파일 성공
}
```

-	const가 맨 앞 부분에 선언된 경우(main에서 위 코드): 포인터 변수 ptr을 이용해서 ptr이 가리키는 변수에 지정된 값을 변경하는 것을 허용하지 않는다. -> `*ptr = 30` 에러 발생<br><br>
-	그러나 실제 변수 num이 상수화되는 것은 아니므로 `num = 40`처럼 변경을 해도 된다.<br><br>
-	const가 포인터 이름 앞에 선언된 경우(main에서 아래 코드): 포인터 변수를 상수로 만든다.<br><br>
-	포인터 변수가 상수라는 뜻은 한 번 주소값이 저장되면 그 값의 변경이 불가능하다는 뜻. 즉, 한 번 가리키기 시작한 변수를 끝까지 가리켜야 한다는 뜻. -> `ptr2 - @num2`에러 발생<br><br>
```C
const int * const ptr = &num;
```
-	위 코드처럼 두 위치에 const를 선언하면 `*ptr=20`, `ptr=&age` 둘 다 불가능하게 된다.<br><br>

### Reference<br>

-	열혈 C 프로그래밍 (윤성우 저) Chapter 14

---
