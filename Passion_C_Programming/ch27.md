Chapter 27 : File Split & Header File Design
--------------------------------------------

---

파일의 분할
----------

```c
extern int num;
extern void Increment(void); //함수의 경우 extern 선언 생략 가능
```

-	컴파일러는 파일단위로 컴파일을 진행하기 때문에 외부 파일에 선언된 변수나 함수를 불러올 때는 extern 선언을 해줘서 컴파일러에게 저 파일들에 있는 정보를 불러오라고 말해줘야 한다.<br><br>

static
------

-	static 전역변수는 외부 파일에서의 접근을 허용하지 않고, 접근 범위를 파일 내부로 제한한다는 의미이다.<br><br>
-	변수, 함수에 static 선언이 가능하다.<br><br>

\#include
---------

> header1.h

```c
{
  puts("hello world");
```

<br>

> header2.h

```c
  return 0;
}
```

<br>

> main.c

```c
#include <stdio.h>

int main(void)
#include "header1.h"
#include "header2.h"
```

-	\#include 지시자는 파일의 내용을 단순히 포함시키는 용도로 사용된다.<br><br>
-	헤더파일은 모두 동일한 디렉터리에 존재해야 컴파일이 된다.<br><br>

헤더 파일을 include 하는 두 가지 방법
-------------------------------------

```c
#include <헤더 파일 이름>
#include "헤더 파일 이름"
#include "C:\Cpower\MyProject\header.h" //절대경로
#include "heager.h" //상대 경로 -> 이 문장을 포함하는 소스파일의 위치와
//동일한 위치로 이 헤더파일을 검색한다.
```

-	<> 방식은 C에서 제공하는 표준헤더파일 디렉터리에서 찾아와서 포함시킨다.<br><br>
-	"" 방식은 해당 문장을 포함하는 소스 파일이 저장된 디렉토리에서 헤더 파일을 찾는다.<br><br>
-	"" 방식은 프로그래머가 정의하는 헤더 파일을 포함시킬 때 사용하며, 헤더 파일의 이름뿐만 아니라 절대 및 상대 경로를 명시해서 지정할 수 있다.<br><br>
- 헤더파일을 선언할 때는 상대경로를 사용하는 것이 좋다.<br><br>
-	외부에 선언된 변수 및 함수를 사용하기 위한 선언을 헤더 파일에 담아 사용한다.<br><br>
-	매크로의 명령문도 파일 단위로 유효하기 때문에, 해당 매크로를 필요로 하는 소스 파일은 해당 헤더 파일을 포함시키면 된다.<br><br>

구조체의 선언
-------------

-	컴파일러는 다른 파일의 정보를 참조하여 컴파일을 진행하지 않기 때문에, 특정 구조체에 대한 선언 및 정의는 이를 필요로 하는 모든 파일에 존재해야 한다.<br><br>
-	동일한 구조체의 정의가 두 군데 이상 존재하면 구조체의 수정 및 확장에 불편하기 때문에, 구조체의 선언 및 정의는 헤더 파일에 삽입하는 것이 좋다.<br><br>

헤더 파일의 중복 삽입 문제
--------------------------

-	프로그램이 복잡해지면서 헤더 파일이 중복으로 삽입되는데, 동일한 구조체가 중복으로 정의된 형태가 되어 컴파일 에러가 발생한다.<br><br>
-	외부 변수 및 함수를 사용하겠다는 `extern` 선언은 컴파일러에게 전달하는 단순 메시지이기 때문에, 중복이 되어도 문제가 되지 않는다.<br><br>
-	그러나 구조체 정의는 컴파일을 하는데 도움을 주는 정보가 아니라 실행 파일의 내용에 직접적인 연관이 있는 정보이기 때문에, 중복될 수 없다.<br><br>

조건부 컴파일을 활용한 중복 삽입 문제 해결<br>
----------------------------------------------

> stdiv2.h

```c
#ifndef __STDIV2_H__
#define __STDIV2_H__

typdef struct div{
  int x, y;
} Div;

#endif
```

<br>

> intdiv4.h

```c
#ifndef __INTDIV4_H__
#define __INTDIV4_H__

#include "stdiv2.h"
Div IntDiv(int num1, int num2);

#endif
//이 파일을 처음 포함하는 소스파일은 __INTDIV4_H__ 라는 이름의 매크로가
//정의되지 않은 상태이므로 조건부 사이에 있는 코드를 실행한다. 그 이후에
//이 파일을 포함하는 소스파일은 __INTDIV4_H__ 이름의 매크로가 존재하기 때문에
//조건부 사이에 있는 코드를 중복으로 정의하지 않는다.
```
<br>

> intdiv4.c

```c
#include "stdiv2.h"

Div IntDiv(int num1, int num2){
  Div dval;
  ...
  return dval;
}
```

<br>

> main.c

```c
#include <stdio.h>
#include "stdiv2.h"
#include "intdiv4.h"
```

- `\#ifndef ~ \#endif` 를 사용해서 중복삽입의 문제를 미연에 방지하는 것이 좋다.<br><br>

가변인자 매개변수의 선언방법<br>
----------------------------------------------
```c
int sum(int n, ...) //... 은 가변인자에 대한 선언
{
  printf("n=%d \n", n);
  return 0;
}
```
- `...` 은 인자의 자료형과 수에 제한이 없음을 의미한다.<br><br>

잘못 전달된 인자들을 추출하는 방법<br>
----------------------------------------------
- 1. `va_list` : 가변인자를 가리킬 수 있는 참조자 선언.<br><br>
- 2. `va_start` : 참조자가 가변인자를 실제로 참조할 수 있도록 한다.<br><br>
- 3. `va_arg` : 참조자를 통해 전달된 정보를 추출한다.<br><br>
- 4. `va_end` : 참조자가 더 이상 가변인자를 가리키지 않도록 해제한다.<br><br>
- 위 변수,함수들을 사용하기 위해서는 헤더파일 `stdarg.h`를 포함해야 한다.<br><br>
```c
#include <stdio.h>
##include <stdarg.h>
int Sum(int n, ...);

int main(void)
{
  printf("1+2=%d \n",Sum(2, 1, 2));
  printf("1+2+3=%d \n",Sum(3, 1, 2, 3));
  printf("1+2+3+4=%d \n",Sum(4, 1, 2, 3, 4));
  return 0;
}

int Sum(int n, ...)
{
  int sum = 0;
  int i;
  va_list vlist;  //가변인자의 참조자 선언

  va_start(vlist, n); //참조대상과 범위 지정
  for(i=0; i<n; i++)
    sum += va_arg(vlist, int);  //값의 추출

  va_end(vlist);  //해제
  return sum;
}
```
- main 함수에서 `printf();` 에서 전달되는 가변인자들은 메모리 공간에 저장된다. 그런데 이름이 없으므로 이들을 참조할 참조자가 필요하다. `va_list`형 변수 선언.<br><br>
- `va_list`가 가변인자들을 참조할 수 있도록 `va_start`함수를 호출. 두 번째 매개변수로 참조할 인자의 갯수 정보가 전달돼야 한다.<br><br>
- `va_arg`함수 두 번째 매개변수로 인자의 참조 대상의 자료형이 와야 한다.<br><br>
- 값의 추출이 끝나면 `vlist`가 더 이상 가변인자를 참조하지 않도록 해제해줘야 한다(메모리의 안전한 사용을 위해). 이를 위해 `va_end`함수 호출.<br><br>

Reference
---------

-	열혈 C 프로그래밍 (윤성우 저) Chapter 27

---
