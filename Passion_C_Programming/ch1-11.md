Chapter 1 - 11 : C Language Basic
---------------------------------

---

### C<br>

-	절차지향적인 Low-Level Language로서, 이식성이 좋으며 기본적으로 성능에 민감한 소프트웨어의 개발에 주로 사용된다.<br><br>
-	사용하는 메모리의 양이 상대적으로 적고, 속도를 저하시키는 요소들을 최소화하는 언어이기 때문에 좋은 성능을 보장할 수 있지만 절대적인 것은 아니다.<br><br>
-	저급 언어의 특성으로 인해, 고급 언어에 비해 더 주의해서 사용해야 한다.<br><br>

### Variable<br>

```C
int main(void){
  int num1;
  int num2;
  num1=0;
  num2=0; //ok
}

int main(void){
  int num1;
  num1=0; //해당 문장은 변수의 선언문이 아니다.
  int num2; //컴파일 에러가 발생하는 지점
  num2=0;
}
```

-	선언만 하고 초기화하지 않으면 쓰레기 값이 저장된다. -> 자바는 자료형별로 디폴트가 있는데 그것과 다르다.<br><br>
-	중괄호 내에 변수를 선언할 경우, 변수 선언문은 중괄호의 앞부분에 위치해야 한다. -> 초기화는 어디서 해도 상관 없다.<br><br>
-	0은 false, 0을 제외한 모든 숫자는 true로 간주한다.<br><br>
-	변수명 규칙을 따르지 않으면 컴파일에러가 발생한다.<br><br>

### scanf()<br>

```C
int main(void){
  int num1, num2, num3;
  scanf("%d %d %d", &num1, &num2, &num3);
}
```

-	`scanf` 함수는 공백을 기준으로 데이터를 구분한다.<br><br>

### Bit Operator : Shift<br>

-	비트의 열을 왼쪽으로 1칸씩 이동시킬 때 마다 정수의 값은 두 배가 된다.<br><br>
-	비트의 열을 오른쪽으로 1칸씩 이동시킬 때 마다 정수의 값은 2로 나누어진다.<br><br>
-	상황에 따라서 곱셈과 나눗셈 연산을 비트의 이동 연산으로 대체할 수 있고, 성능 향상으로 이어진다.<br><br>
-	음의 값인 비트를 오른쪽으로 이동시킬 때, 일부 CPU는 음의 값(MSB)을 상관하지 않고 0을 채우기도 한다.<br><br>

### Data Type<br>

![image](https://user-images.githubusercontent.com/56240505/71668307-b5bde500-2dab-11ea-8067-e1887e734303.png)<br><br>

-	자료형은 데이터를 표현하는 기준으로, 변수와 상수도 자료형에 근거하여 메모리 공간을 할당 받는다.<br><br>
-	ANSI는 자료형 별 크기를 정확히 제한하고 있지 않아서, 컴파일러마다 자료형 별 크기가 상이할 수 있다.<br><br>
-	`sizeof()` 연산자를 통해 자료형 별 바이트 크기를 확인할 수 있으며, `sizeof`는 함수가 아닌 연산자이다.<br><br>
-	int보다 작은 크기의 데이터는 int로 형 변환하여 연산이 진행되는데, 일반적으로 CPU가 처리하기에 가장 적합한 크기의 정수 자료형이기 때문이다.<br><br>
-	따라서 int 연산의 속도가 다른 자료형의 연산 속도에비해서 동일하거나 더 빠르며, 연산의 횟수가 빈번한 경우에는 저장되는 값이 작더라도 int형 변수를 선언하는것이 좋다.<br><br>
-	char 및 short는 데이터의 양이 많아서 연산 속도보다 데이터의 크기를 줄이는 것이 더 중욯나 데이터의 경우 유용하게 사용된다.<br><br>
-	char는 문자의 표현을 목적으로 정의되었으나 엄연히 정수형이며, 문자는 의미 있는 연산이 많지 않기 때문에 int보다 char가 적합하다.<br><br>

### unsigned<br>

-	정수 자료형의 이름에 한해서 unsigned 선언을 추가하면, 0 이상의 값만 표현하는 자료형이 되어 표현할 수 있는 값의 범위가 양의 정수 방향으로 두 배 더 넓어지게 된다.<br><br>
-	데이터의 부호를 결정짓는데 사용되는 MSB 조차 값의 크기를 나타내는 비트로 사용되기 때문이다.<br><br>
-	일반적인 정수 자료형의 선언은 signed 선언과 동일하기 때문에 생략이 가능하지만, char의 경우 컴파일러마다 예외가 있기 때문에 char와 signed char가 다를 수 있다.<br><br>

### Constant & Literal<br>

```C
int main(void){
  int num = 30 + 40;
  sizeof('a'); //4
  const int MAX = 100; //일반적인 Symbolic Constant
}
```

-	30과 40이라는 정수도 메모리 상에 존재해야 CPU의 연산 대상이 될 수 있다.<br><br>
-	따라서 메모리 공간에 상수 형태로 저장이 되며, 변수와 달리 이름이 없기 때문에 literal 이라고 칭한다.<br><br>
-	크기에 제약이 없는 경우 일반적으로 정수형 literal 상수는 int, 실수형 literal 상수는 double 자료형으로 저장된다.<br><br>
-	심볼릭 상수는 선언과 초기화를 분리시킬 수 없다.<br><br>

### Suffix for Constant<br>

![image](https://user-images.githubusercontent.com/56240505/71669033-b86e0980-2dae-11ea-9717-7ec3671a7deb.png)<br><br>

-	변수를 초기화할 때 리터럴 상수의 자료형보다 크기가 작은 변수에 저장되는 경우, 데이터 손실 경고 메시지가 발생하기 때문에 적합한 접미사를 사용한다.<br><br>

### for<br>

```C
int main(void){
  int num;
  for(num=0; num<3; num++)
    printf("aaa");
}
```

-	일부 컴파일러는 for의 초기식 위치의 변수 선언을 허용하지 않기 때문에 주의한다.<br><br>
-	초기식과 증감식은 경우에 따라 필요가 없으면 생략이 가능하다.<br><br>

### goto<br>

```C
int main(void){
  if(num==1)
    goto ONE;
  else if(num==2)
    goto TWO;

ONE :
      printf("블라블라");

TWO :
      printf("블라블라");
}
```

-	절차지향 언어에서 프로그램의 자연스러운 흐름을 방해하는 문법은 부정적이기 때문에 잘 쓰이지 않는다.<br><br>
-	`goto` 를 통해 특정 레이블로 이동할 수 있다.<br><br>

### 함수의 정의와 그에 따른 원형의 선언<br>

```C
int Increment(int n); //함수의 선언
int Increment(int); //매개변수의 이름은 생략이 가능

int main(void){
  int num=2;
  num=Increment(num);
  return 0;
}

int Increment(int n){ //함수의 정의
  n++;
  return n;
}
```

-	함수는 호출되기 전에 미리 정의되어야 한다.<br><br>
-	그러나 abstract class 및 interface와 유사하게 함수의 원형에 대해 먼저 선언해놓으면 에러가 발생하지 않는다.<br><br>

### Local Variable<br>

-	지역 변수는 해당 선언문이 실행될 때 메모리 공간(Stack)에 할당되며, 선언문이 존재하는 함수가 반환을 하면 메모리 공간에서 소멸된다.<br><br>
-	선언된 지역 내에서만 유효하기 때문에 선언된 지역이 다르면 이름이 같아도 문제가 되지 않는다.<br><br>
-	지역 변수는 외부에 선언된 동일한 이름의 변수를 가리게 된다.<br><br>
-	매개 변수도 지역 변수의 일종이다.<br><br>

### Global Variable<br>

-	프로그램의 시작과 동시에 메모리 공간에 할당되어 종료 시 까지 존재한다.<br><br>
-	별도의 값으로 초기화하지 않으면 0으로 초기화되며, 프로그램 전체 영역 어디서든 접근이 가능하다.<br><br>
-	전역 변수와 동일한 이름의 지역 변수가 선언되면, 해당 지역 내에서는 전역 변수 대신 지역 변수로의 접근이 이루어진다.<br><br>
-	복잡성 이슈 등으로 인해 전역 변수의 사용은 자제해야 한다.<br><br>

### Static Local Variable<br>

```C
void SimpleFunc(void){
  static int num1 = 0;
  int num2 = 0;
  num1++; num2++;
  printf("%d %d", num1, num2);
}

int main(void){
  int i;
  for(i=0; i<3; i++)
    SimpleFunc();
  return 0;
}

/*
결과
1, 1
2, 1
3, 1
*/
```

-	선언된 함수 내에서만 접근이 가능하며, 딱 1회 초기화되고 프로그램 종료 시까지 메모리 공간에 존재한다.<br><br>
-	static으로 선언된 지역 변수는 전역 변수와 동일한 시기에 할당되고 소멸된다.<br><br>
-	접근의 범위를 선언된 함수 내로 제한하기 때문에 전역 변수보다 안정적이다.<br><br>

### Register Variable<br>

-	지역 변수에 register 키워드 선언을 추가할 수 있으며, 해당 변수는 CPU 내 레지스터라는 메모리 공간에 저장될 확률이 높아진다.<br><br>
-	그러나 힌트를 주는 선언일 뿐, register 등록 여부는 컴파일러가 결정한다.<br><br>
-	레지스터는 중요하고 비싼 메모리 공간이므로, 전역 변수에 register를 선언할 수 없다.<br><br>

### Array<br>

```C
int main(void){
  int len = 20;
  int arr[len]; //범용적인 컴파일을 위해 배열 길이 정보를 상수로 지정함
  int arr2[] = {1,2,3,4,5,6,7}; //컴파일러에 의해 자동으로 7이 삽입됨
  int arr3[5] = {1, 2}; //3, 4, 5번째 배열 요소는 0으로 채워짐

  char str[] = "Good Morning!"; //컴파일러에 의해 자동으로 14가 삽입됨
  char arr4[] = {'h', 'i'}; //null 문자가 없어서 문자 배열
  char arr5[] = {'h', 'i', '\0'}; //null 문자가 있어서 문자열
}
```

-	문자열의 끝에는 항상 `\0` 이라는 null 특수 문자가 삽입된다.<br><br>

-	`scanf()` 를 통해 문자열을 입력받을 때 입력 받는 배열의 이름 앞에 & 연산자를 붙이면 안 된다.<br><br>

-	`scanf()` 는 데이터를 구분 짓는 기준이 공백이기 때문에, 문장을 입력 받기에는 적절하지 않다.<br><br>

### Reference<br>

-	열혈 C 프로그래밍 (윤성우 저) Chapter 1 - 11

---
