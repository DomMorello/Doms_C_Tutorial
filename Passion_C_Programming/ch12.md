Chapter 12 : Pointer
--------------------

---

### Pointer<br>

```C
int main(void){
  int num = 7;
  int * pnum; //포인터 변수 pnum의 선언
  pnum = &num;  //num의 주소 값을 포인터 변수 pnum에 저장
}
```

-	포인터를 이용하면 메모리에 직접 접근이 가능하기 때문에 C언어를 Low level 언어의 특성을 지닌다고 한다.<br><br>
-	변수가 메모리에 할당되는데 이 때 메모리가 갖는 주소값도 정수값이기 때문에 저장이 가능하다.<br><br>
-	포인터 변수는 이 주소값을 메모리에 저장하기 위한 변수이다.<br><br>
-	포인터는 크게 '변수 형태의 포인터'와 '상수 형태의 포인터'가 있다.<br><br>
-	`pnum`은 포인터 변수의 이름이며, `int *` 는 int형 변수의 주소 값을 저장하는 포인터 변수의 선언이다.<br><br>
- `&` 연산자는 '오른쪽에 등장하는 피연산자의 주소 값을 반환하는 연산자'이다.
-	포인터 변수의 크기(=주소 값의 크기)는 32비트에서는 4바이트, 64비트에서는 8바이트이다.<br><br>

### Pointer Variable 선언<br>

```C
type * // type형 포인터
type * ptr; // type 형 포인터 변수 ptr
```

-	주소 값은 동일한 시스템에서 크기가 같고 모두 정수의 형태를 띠지만 변수의 자료형에 따라 포인터 선언이 다르다.<br><br>
-	위 코드와 같이 함으로써 포인터 변수의 선언형태만 보고 현재 가리키는 변수의 자료형을 짐작할 수 있다.<br><br>
-	포인터 형이 존재하는 이유는 포인터 기반의 메모리 접근 기준을 마련하기 위함이며, 포인터에 형이 존재하지 않는다면 * 연산을 통한 메모리의 접근이 불가능하다. -> 변수의 자료형과 포인터의 형이 일치하지 않으면 * 연산을 했을 때 의미없는 해석이 발생한다.<br><br>

### Operator &<br>

```C
int main(void){
  int num = 5;
  int * pnum = &num;
  double * pnum1 = &num; //일치하지 않음
}
```

-	`&` 연산자는 피연산자의 주소 값을 반환하는 연산자이며, 상수는 피연산자가 될 수 없다.<br><br>
-	변수의 자료형에 맞지 않는 포인터 변수의 선언은 컴파일 에러는 발생하지 않지만, 포인터 관련 * 연산 시 문제가 발생한다.<br><br>

### Operator \*<br>

```C
int main(void){
  int num = 10;
  int * pnum = &num;
  *pnum = 20;
  printf("%d", *pnum);
  //포인터 변수 pnum이 가리키는 메모리 공간인 변수 num에 정수 20을 저장하고 출력하라
  //(-> num = 20)
}
```

-	`*` 연산자는 포인터가 가리키는 메모리 공간에 접근할 때 사용하는 연산자이다.<br><br>
### 잘못된 포인터의 사용

```C
int main(void){
  int * ptr;  //포인터 변ㅅ수 ptr은 쓰레기 값으로 초기화 됨
  *ptr = 200;
}
```
- 위와 같은 포인터 변수는 쓰레기값이 저장되면서 어디를 가리키는지 알 수 없게 되어 치명적인 문제를 일으킬 수 있다.

```C
int main(void){
  int * ptr = 125;  //125번지가 어딘 줄 알고?
  *ptr = 10;
}
```
- 위의 코드는 125가 어디인지도 모르면서 초기화를 한 것이므로 쓰레기값으로 초기화되는 것과 같다.

### Null Pointer<br>

```C
int main(void){
  int * ptr1 = 0;
  int * ptr2 = NULL;
}
```
-	ptr1, ptr2 처럼 0(=NULL)을 통해 아무데도 가리키지 않는다는 명시를 해야 하며, NULL 키워드는 상수 0으로 정의되어 있다.<br><br>

### Reference<br>

-	열혈 C 프로그래밍 (윤성우 저) Chapter 12

---
